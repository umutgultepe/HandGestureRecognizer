/*
-----------------------------------------------------------------------------
Filename:    HandGestureRecognizer.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC10 (July 2011)
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/
#include "StdAfx.h"
#include "HandGestureRecognizer.h"

#define averaging_size 15
std::vector<float> ratios(averaging_size);
//-------------------------------------------------------------------------------------
HandGestureRecognizer::HandGestureRecognizer(void)
{
}
//-------------------------------------------------------------------------------------
HandGestureRecognizer::~HandGestureRecognizer(void)
{
	if (mKinect) delete mKinect;
}

void SetupDepthMaterial()
{
	// Create the texture
	Ogre::TexturePtr depthTexture = Ogre::TextureManager::getSingleton().createManual(
			"MyDepthTexture", // name
			ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
			TEX_TYPE_2D,      // type
			m_Width, m_Height,         // width & height
			0,                // number of mipmaps
			PF_BYTE_BGRA,     // pixel format
			TU_DYNAMIC_WRITE_ONLY_DISCARDABLE);

		
	// Create a material using the texture
	MaterialPtr material = MaterialManager::getSingleton().create(
			"DepthTextureMaterial", // name
			ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	material->getTechnique(0)->getPass(0)->createTextureUnitState("MyDepthTexture");
	material->getTechnique(0)->getPass(0)->setSceneBlending(SBT_TRANSPARENT_ALPHA);
}


//-------------------------------------------------------------------------------------
void HandGestureRecognizer::createScene(void)
{
    Ogre::Entity* ogreHead = mSceneMgr->createEntity("Head", "ogrehead.mesh");

    Ogre::SceneNode* headNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
    headNode->attachObject(ogreHead);

    // Set ambient light
    mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5, 0.5, 0.5));

    // Create a light
    Ogre::Light* l = mSceneMgr->createLight("MainLight");
    l->setPosition(20,80,50);

	SetupDepthMaterial();


	mDepthPanel = Ogre::OverlayManager::getSingleton().createOverlayElement("Panel","DepthPanel");
	mDepthPanel->setMaterialName("DepthTextureMaterial");
	mDepthPanel->setMetricsMode(Ogre::GMM_RELATIVE);
	mDepthPanel->setWidth(0.25);
	mDepthPanel->setHeight(0.25*m_Height/m_Width);
	mDepthPanel->setHorizontalAlignment(GHA_RIGHT);
	mDepthPanel->setVerticalAlignment(GVA_BOTTOM);
	mDepthPanel->setLeft(-mDepthPanel->getWidth());
	mDepthPanel->setTop(-mDepthPanel->getHeight());
		
	mTrayMgr->getTraysLayer()->add2D((Ogre::OverlayContainer*)mDepthPanel);

	if(mQuitSlider == NULL)
	{
		mQuitSlider = createYesNoSlider(TL_NONE,"QuitSlider","Quit?",300,200,0,1,10,mTrayMgr);
		mQuitSlider->hide();
	}

	mKinect=new KinectController();
	mKinect->m_quitSlider = mQuitSlider;

	StringVector items;
	items.push_back("Ratio");
	items.push_back("Depth");
	items.push_back("Sum");
	help = mTrayMgr->createParamsPanel(TL_TOPLEFT, "HelpMessage", 200, items);

}

bool HandGestureRecognizer::frameRenderingQueued(const Ogre::FrameEvent& evt)
{
	mKinect->addTime(evt.timeSinceLastFrame);

	//Handstate handS=HAND_UNKNOWN;



	mKinect->m_HandTracker->setUserID(mKinect->m_candidateID);
	float tVar=-1;
	if (!mKinect->m_HandTracker->isSetUp() && mKinect->m_UserGenerator.GetSkeletonCap().IsTracking(mKinect->m_candidateID))
		tVar=0;
	else
		tVar=mKinect->m_HandTracker->UpdateDepthTexture(mKinect->m_front);
	help->setParamValue("Depth",StringConverter::toString( (float)tVar,3 ));
	
	

	if (tVar==0)
		mKinect->m_HandTracker->initROI(mKinect->m_candidateID);
	else if (tVar!=-1)
	{
		float sum=0;
		for (int i=0;i<averaging_size-1;i++)
		{
			ratios.at(i)=ratios.at(i+1);
			sum+=ratios.at(i);
		}
		ratios.at(averaging_size-1)=tVar;
		sum+=tVar;
		sum/=averaging_size;
		help->setParamValue("Sum",StringConverter::toString( (float)sum,3 ));
		if (sum>4.0)
		{
			mSceneMgr->setAmbientLight(Ogre::ColourValue(0.0, 0.0, 0.5));
		}
		else 
		{
			mSceneMgr->setAmbientLight(Ogre::ColourValue(0.0, 0.5, 0.0));
		}
	}
	else
		mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5, 0.0, 0.0));
	return BaseApplication::frameRenderingQueued(evt);
}


bool HandGestureRecognizer::keyReleased( const OIS::KeyEvent &arg )
{
	mKinect->injectKeyUp(arg);
	return BaseApplication::keyReleased(arg);
}

bool HandGestureRecognizer::keyPressed( const OIS::KeyEvent &arg )
{
	if (arg.key== OIS::KC_V)
		mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5, 0.0, 0.0));
	else if (arg.key== OIS::KC_B)
		mSceneMgr->setAmbientLight(Ogre::ColourValue(0.0, 0.0, 0.5));
	else if (arg.key== OIS::KC_N)
		mSceneMgr->setAmbientLight(Ogre::ColourValue(0.0, 0.5, 0.0));
	mKinect->injectKeyDown(arg);
	return BaseApplication::keyPressed(arg);
}



#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
    int main(int argc, char *argv[])
#endif
    {
        // Create application object
        HandGestureRecognizer app;

        try {
            app.go();
        } catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
            MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            std::cerr << "An exception has occured: " <<
                e.getFullDescription().c_str() << std::endl;
#endif
        }

        return 0;
    }

#ifdef __cplusplus
}
#endif
